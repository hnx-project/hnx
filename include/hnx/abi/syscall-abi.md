# HNX 系统调用 AArch64 ABI 约定

## 概述

本文档定义了 HNX 微内核操作系统在 AArch64 架构上的系统调用应用程序二进制接口（ABI）约定。这些约定确保了用户空间和内核空间之间的正确交互。

## 寄存器使用约定

### 系统调用参数传递

HNX 遵循标准的 AArch64 系统调用约定：

| 寄存器 | 用途                          | 调用者保存？ |
|--------|-------------------------------|--------------|
| x0     | 系统调用号                    | 是           |
| x1-x6  | 参数 1-6                      | 是           |
| x8     | 系统调用号（备用/兼容性）     | 是           |
| x7     | 未使用                        | 是           |
| x9-x15 | 临时寄存器                    | 是           |
| x16-x17| 链接寄存器（由调用破坏）      | 是           |
| x18    | 平台保留寄存器                | 平台特定     |
| x19-x28| 被调用者保存寄存器            | 否           |
| x29    | 帧指针（FP）                  | 被调用者保存 |
| x30    | 链接寄存器（LR）              | 被调用者保存 |
| SP     | 栈指针                        | -           |

### 系统调用执行流程

1. **用户空间准备**：
   - 将系统调用号放入 `x8` 寄存器
   - 将参数放入 `x0-x5` 寄存器（最多6个参数）
   - 执行 `svc #0` 指令

2. **内核异常处理**：
   - 异常向量表跳转到 `exception_handler_sync`
   - 保存所有调用者保存寄存器（x0-x18）到栈上
   - 保存所有被调用者保存寄存器（x19-x28）到栈上
   - 调用 Rust SVC 处理程序

3. **内核系统调用分发**：
   - 从栈上读取保存的 `x8` 寄存器（偏移量 `sp+80`）
   - 从栈上读取保存的参数寄存器（x0-x5，偏移量见下文）
   - 调用对应的系统调用处理函数
   - 将返回值写入 `x0` 寄存器在栈上的位置（偏移量 `sp+144`）

4. **返回用户空间**：
   - 恢复所有保存的寄存器
   - 执行 `eret` 指令返回用户空间

## 栈布局

在进入异常处理程序时，栈上寄存器保存区域的布局如下：

```
高地址
+-----------------+
| x25             | <- sp + 0 (第一次压入)
| xzr (占位符)    |
+-----------------+
| x23             | <- sp + 16
| x24             |
+-----------------+
| x21             | <- sp + 32
| x22             |
+-----------------+
| x19             | <- sp + 48
| x20             |
+-----------------+
| x18             | <- sp + 64
| xzr (占位符)    |
+-----------------+
| x16             | <- sp + 80
| x17             |
+-----------------+
| x14             | <- sp + 96
| x15             |
+-----------------+
| x12             | <- sp + 112
| x13             |
+-----------------+
| x10             | <- sp + 128
| x11             |
+-----------------+
| x8              | <- sp + 144
| x9              |
+-----------------+
| x6              | <- sp + 160
| x7              |
+-----------------+
| x4              | <- sp + 176
| x5              |
+-----------------+
| x2              | <- sp + 192
| x3              |
+-----------------+
| x0              | <- sp + 208
| x1              |
+-----------------+
低地址
```

**重要偏移量**：
- `x8` 保存在 `sp + 144`（但通过 `saved_x8` 参数传递）
- `x0` 保存在 `sp + 208`（恢复时最先弹出）
- 系统调用返回值写入 `sp + 208`（x0的位置）

## 返回值约定

- 成功：返回非负值（进程ID、字节数等）
- 失败：返回负的错误码（定义在 `include/hnx/abi/errors.h`）

## 内存访问约定

1. **用户内存访问**：内核在访问用户空间内存前必须验证权限
2. **对齐要求**：所有指针必须自然对齐
3. **内存屏障**：系统调用不保证内存顺序，需要时使用显式屏障

## 编译器注意事项

### Rust 内联汇编约束

用户空间系统调用包装器必须正确声明寄存器约束：

```rust
unsafe {
    asm!(
        "svc #0",
        in("x8") syscall_number,      // 系统调用号
        in("x0") arg0,                // 参数0
        in("x1") arg1,                // 参数1
        in("x2") arg2,                // 参数2
        in("x3") arg3,                // 参数3
        in("x4") arg4,                // 参数4
        in("x5") arg5,                // 参数5
        lateout("x0") retval,         // 返回值
        clobber_abi("C"),             // 声明所有调用者保存寄存器可能被修改
        options(nostack, preserves_flags)
    );
}
```

### 关键要求

1. **`clobber_abi("C")`**：必须包含此声明，告知编译器所有调用者保存寄存器（x0-x18）可能被修改
2. **`nostack`**：系统调用不应使用栈（除了通过SVC机制）
3. **寄存器分配**：避免在系统调用前后重用 `x8` 寄存器

## 错误处理

### 用户空间错误码

系统调用返回的错误码遵循以下模式：
- `>= 0`：成功，具体含义取决于系统调用
- `< 0`：错误，使用 `include/hnx/abi/errors.h` 中的定义

### 内核错误处理

内核中的系统调用实现应：
1. 验证所有参数
2. 检查用户内存访问权限
3. 返回适当的错误码而非panic

## 安全性要求

1. **参数验证**：内核必须验证所有来自用户空间的参数
2. **内存隔离**：用户空间不能直接访问内核内存
3. **权限检查**：基于能力的访问控制
4. **寄存器清理**：返回用户空间前清除敏感信息

## 兼容性保证

### 稳定接口

以下元素被视为稳定ABI的一部分：
- 系统调用号（定义在 `include/hnx/abi/syscalls.h`）
- 错误码定义
- 基本类型定义
- 寄存器使用约定

### 可能变化的元素

以下元素可能在版本间变化：
- 内部数据结构布局
- 未文档化的行为
- 性能特性

## 调试支持

### 内核日志

系统调用入口和出口应记录调试信息：
- 系统调用号和参数
- 返回值和错误码
- 执行时间统计（可选）

### 用户空间跟踪

通过特殊的系统调用或调试接口支持用户空间跟踪。

## 示例

### 简单的系统调用包装器

```rust
#[inline(never)]  // 防止内联导致寄存器分配冲突
pub fn write(fd: i32, buf: &[u8]) -> isize {
    let ret: isize;
    unsafe {
        asm!(
            "svc #0",
            in("x8") HNX_SYS_WRITE,
            in("x0") fd as usize,
            in("x1") buf.as_ptr() as usize,
            in("x2") buf.len(),
            lateout("x0") ret,
            clobber_abi("C"),
            options(nostack, preserves_flags)
        );
    }
    ret
}
```

## 参考

1. ARM Architecture Reference Manual ARMv8-A
2. Linux AArch64 System Call ABI
3. Zircon (Fuchsia) System Call ABI

---

*文档版本：1.0*  
*最后更新：2025年12月28日*  
*适用于：HNX v0.2.0-alpha.1+*