/* automatically generated by rust-bindgen 0.66.1 */

pub const ZX_OK: u32 = 0;
pub const ZX_ERR_INTERNAL: i32 = -1;
pub const ZX_ERR_NOT_SUPPORTED: i32 = -2;
pub const ZX_ERR_NO_RESOURCES: i32 = -3;
pub const ZX_ERR_NO_MEMORY: i32 = -4;
pub const ZX_ERR_INVALID_ARGS: i32 = -10;
pub const ZX_ERR_BAD_HANDLE: i32 = -11;
pub const ZX_ERR_WRONG_TYPE: i32 = -12;
pub const ZX_ERR_BAD_STATE: i32 = -13;
pub const ZX_ERR_TIMEOUT: i32 = -14;
pub const ZX_ERR_SHOULD_WAIT: i32 = -15;
pub const ZX_ERR_CANCELED: i32 = -16;
pub const ZX_ERR_PEER_CLOSED: i32 = -17;
pub const ZX_ERR_NOT_FOUND: i32 = -18;
pub const ZX_ERR_ALREADY_EXISTS: i32 = -19;
pub const ZX_ERR_PERMISSION_DENIED: i32 = -30;
pub const ESUCCESS: u32 = 0;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const HNX_SYS_CHANNEL_CREATE: u32 = 1;
pub const HNX_SYS_CHANNEL_WRITE: u32 = 2;
pub const HNX_SYS_CHANNEL_READ: u32 = 3;
pub const HNX_SYS_PROCESS_CREATE: u32 = 257;
pub const HNX_SYS_PROCESS_START: u32 = 258;
pub const HNX_SYS_THREAD_CREATE: u32 = 513;
pub const HNX_SYS_THREAD_START: u32 = 514;
pub const HNX_SYS_VMO_CREATE: u32 = 769;
pub const HNX_SYS_VMO_READ: u32 = 770;
pub const HNX_SYS_VMO_WRITE: u32 = 771;
pub const HNX_SYS_WRITE: u32 = 4097;
pub const HNX_SYS_READ: u32 = 4098;
pub const HNX_SYS_OPEN: u32 = 4099;
pub const HNX_SYS_CLOSE: u32 = 4100;
pub const HNX_SYS_EXIT: u32 = 4101;
pub const HNX_SYS_CREAT: u32 = 85;
pub const HNX_SYS_UNLINK: u32 = 87;
pub const HNX_SYS_MKDIR: u32 = 83;
pub const HNX_SYS_RMDIR: u32 = 84;
pub const HNX_SYS_MMAP: u32 = 90;
pub const HNX_SYS_MUNMAP: u32 = 91;
pub const HNX_SYS_MPROTECT: u32 = 92;
pub const HNX_SYS_GETPID: u32 = 20;
pub const HNX_SYS_FORK: u32 = 57;
pub const HNX_SYS_KILL: u32 = 62;
pub const HNX_SYS_SETPGID: u32 = 109;
pub const HNX_SYS_GETPGID: u32 = 121;
pub const HNX_SYS_GETPPID: u32 = 110;
pub const HNX_SYS_WAIT4: u32 = 61;
pub const HNX_SYS_DRIVER_REGISTER: u32 = 2001;
pub const HNX_SYS_DRIVER_REQUEST_IRQ: u32 = 2002;
pub const HNX_SYS_DRIVER_MAP_MMIO: u32 = 2003;
pub const HNX_SYS_DRIVER_DMA_ALLOC: u32 = 2004;
pub const HNX_SYS_SOCKET: u32 = 41;
pub const HNX_SYS_BIND: u32 = 49;
pub const HNX_SYS_CONNECT: u32 = 42;
pub const HNX_SYS_LISTEN: u32 = 50;
pub const HNX_SYS_ACCEPT: u32 = 43;
pub const HNX_SYS_SEND: u32 = 44;
pub const HNX_SYS_RECV: u32 = 45;
pub const HNX_SYS_DLOPEN: u32 = 1001;
pub const HNX_SYS_DLCLOSE: u32 = 1002;
pub const HNX_SYS_DLSYM: u32 = 1003;
pub const HNX_SYS_YIELD: u32 = 24;
pub const HNX_SYS_IPC_WAIT: u32 = 301;
pub const HNX_SYS_IPC_WAKE: u32 = 302;
pub const HNX_SYS_EP_CREATE: u32 = 303;
pub const HNX_SYS_EP_SEND: u32 = 304;
pub const HNX_SYS_EP_RECV: u32 = 305;
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_fast16_t = i16;
pub type uint_fast16_t = u16;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type intmax_t = ::core::ffi::c_long;
pub type uintmax_t = ::core::ffi::c_ulong;
pub type pid_t = i32;
pub type fd_t = i32;
pub type handle_t = u32;
pub type status_t = i32;
pub type mmap_prot_t = u32;
pub type sys_result_t = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zx_channel_create_args_t {
    pub options: u32,
    pub out0: *mut u32,
    pub out1: *mut u32,
}
#[test]
fn bindgen_test_layout_zx_channel_create_args_t() {
    const UNINIT: ::core::mem::MaybeUninit<zx_channel_create_args_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<zx_channel_create_args_t>(),
        24usize,
        concat!("Size of: ", stringify!(zx_channel_create_args_t))
    );
    assert_eq!(
        ::core::mem::align_of::<zx_channel_create_args_t>(),
        8usize,
        concat!("Alignment of ", stringify!(zx_channel_create_args_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zx_channel_create_args_t),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out0) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zx_channel_create_args_t),
            "::",
            stringify!(out0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zx_channel_create_args_t),
            "::",
            stringify!(out1)
        )
    );
}
extern "C" {
    pub fn zx_channel_create(options: u32, out0: *mut u32, out1: *mut u32) -> i32;
}
extern "C" {
    pub fn zx_channel_write(
        handle: u32,
        options: u32,
        bytes: *const u8,
        num_bytes: usize,
        handles: *const u32,
        num_handles: usize,
    ) -> i32;
}
extern "C" {
    pub fn zx_channel_read(
        handle: u32,
        options: u32,
        bytes: *mut u8,
        handles: *mut u32,
        num_bytes: usize,
        num_handles: usize,
        actual_bytes: *mut usize,
        actual_handles: *mut usize,
    ) -> i32;
}
