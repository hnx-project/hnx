# 开发约定 (Development Conventions)

为了确保 HNX 项目的代码质量、一致性和可维护性，所有贡献者都应严格遵循以下开发约定。这些约定涵盖了代码风格、跨架构开发、文档注释以及服务开发等方面。

## 1. 代码风格

-   **Rust 代码:** 遵循 Rust 官方的标准格式化工具 `cargo fmt`。在提交代码之前，请确保运行 `cargo fmt`。
-   **C 代码:** 内核头文件（如果存在）应遵循类似 Unix 内核的编码约定。
-   **Python 脚本:** 配置脚本和实用工具遵循 Python 的 PEP 8 编码规范。

## 2. 跨架构开发约定

HNX 旨在成为一个跨架构的微内核操作系统，因此在编写代码时必须考虑到不同处理器架构的兼容性。`kernel/src/arch` 目录是实现这一目标的核心。

-   **条件编译:** 使用 `#[cfg(target_arch = "aarch64")]` 等 Rust 属性来标记架构特定代码。通用代码中严禁出现特定架构的硬编码。
-   **架构抽象层:** 通用代码应通过 `trait` 和抽象接口来调用架构特定的功能。内存管理、中断处理和上下文切换等关键功能必须提供通用接口，并且架构特定实现必须实现这些接口。
-   **文件组织:** 架构相关代码应组织在 `kernel/src/arch/` 对应的子目录中，例如 `aarch64/` 用于 AArch64 架构的实现。
-   **构建系统支持:** `configs/arch/` 目录包含架构特定配置，`meson.build` 支持通过 `ARCH` 变量切换目标架构。

## 3. 文档注释规范

为支持自动生成高质量的中文文档，所有代码都应遵循严格的文档注释规范。

-   **中文文档注释:** 所有公共 API、模块、结构体、枚举和函数都必须包含中文文档注释，使用标准的 Rust 文档注释格式 `///` 和 `//!`。
-   **注释内容:** 
    -   **模块级 (`//!`):** 描述模块的整体功能和架构位置。
    -   **结构体/枚举级 (`///`):** 描述数据类型的用途和字段含义。
    -   **函数/方法级 (`///`):** 包含参数 (`# 参数`)、返回值 (`# 返回值`)、示例 (`# 示例`) 和注意事项 (`# 注意`)。
-   **自动化文档生成:** 确保所有公共项都有完整文档，避免 `missing_docs` 警告。
-   **命名约定:** 函数、变量、类型使用英文命名（遵循 Rust 命名规范），仅在注释和文档中使用中文进行解释说明。

## 4. 服务开发规范

用户空间服务的开发遵循统一的架构和约定，以确保服务间的高效协作和系统稳定性。

-   **服务命名:** 所有服务 crate 都应使用 `-service` 后缀（例如 `ipcrouter-service`）。
-   **服务框架:** 建议使用 `hnxlib::ipc::ServiceFramework` 来实现服务的自动注册和消息处理。
-   **IPC 通信:** 强制使用类型安全的 `Endpoint` 进行进程间通信，并处理统一的 `IpcError` 错误类型。

## 5. 测试与调试约定

-   **测试日志:** 所有测试日志都应包含测试标志 `[TEST]` 并使用 `test!` 宏打印。测试完成后应移除或注释这些日志。
-   **`test!` 宏:** 专门用于打印测试信息，格式为 `[TEST] <消息>`，其优先级高于 `warn!`。
-   **非内核代码:** 除内核代码外，其他代码（如用户空间服务）应使用 `println!` 等标准打印宏，而不是 `test!` 宏。

## 6. Git 提交信息规范

-   遵循 [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) 规范，确保提交历史清晰、可追溯。
-   提交信息应简洁明了，重点说明本次变更的 **目的 (why)**，而非仅仅 **内容 (what)**。

遵循这些约定有助于所有贡献者协同工作，并共同构建一个高质量的 HNX 操作系统。