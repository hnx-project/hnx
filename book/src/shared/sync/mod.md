# HNX 同步原语 (Synchronization Primitives)

`shared/src/sync` 模块是 HNX 操作系统中核心同步原语的集合。这些原语旨在提供在 `no_std` 环境下运行所需的并发控制机制，它们被设计为可以在内核和用户空间组件中安全高效地使用，以保护共享数据和协调任务执行。

## 设计理念

-   **轻量级:** 尽可能地保持简单和高效，避免不必要的抽象。
-   **`no_std` 兼容:** 不依赖于 Rust 标准库，可以直接在裸机或操作系统内核环境中使用。
-   **跨环境可用:** 提供的原语适用于内核上下文和用户空间服务。
-   **基本功能:** 当前实现主要侧重于提供满足 HNX 核心需求的基础同步功能，部分高级特性（如等待队列、条件唤醒）可能使用 `spin_loop` 进行简化。

## 核心同步原语

### 互斥锁 (Mutex)

`Mutex<T>` 提供了一种互斥访问共享数据的方式。在任何时刻，只有一个任务可以持有互斥锁并访问其内部数据，从而防止数据竞争。

-   **实现特点:** 当前实现是一个简单的自旋锁 (Spinlock)，即当锁被占用时，尝试获取锁的任务会持续忙等待，直到锁可用。这在短临界区和处理器数量不多的情况下是可接受的，但在高竞争或单核环境中可能导致效率低下。
-   **使用场景:** 保护对共享内存结构、计数器等资源的互斥访问。

### 信号量 (Semaphore)

`Semaphore` 是一种计数信号量，用于控制对有限资源的访问。它维护一个内部计数器，任务通过 `acquire` 减少计数器并获取资源，通过 `release` 增加计数器并释放资源。

-   **实现特点:** 类似于自旋锁，当 `acquire` 尝试获取一个不可用资源时，任务会自旋等待。
-   **使用场景:** 限制并发访问的数量（例如，限制同时运行的线程数），或实现生产者-消费者模型中的资源计数。

### 条件变量 (Condvar)

`Condvar` (Condition Variable) 允许任务等待某个条件变为真。它通常与 `Mutex` 结合使用，任务在等待条件时会释放互斥锁，并在条件满足时被唤醒重新获取锁。

-   **实现特点:** 当前实现较为简化，`wait` 函数会使任务进入忙等待 (`spin_loop`)，直到被 `notify_one` 或 `notify_all` 唤醒。**注意：** 目前的 `wait` 实现会无限自旋，需要配合更复杂的调度器才能实现真正的阻塞等待。
-   **使用场景:** 协调任务之间的复杂同步，例如当一个任务需要等待另一个任务完成特定操作后才能继续执行。

### 屏障 (Barrier)

`Barrier` 允许一组任务在某个共同点上同步。所有任务都到达屏障后，才能继续执行。

-   **实现特点:** 内部使用 `Mutex`、`Semaphore` 和 `Condvar` 来协调多个任务的到达和释放。当所有预期任务都到达屏障后，它们会被同时释放。
-   **使用场景:** 在并行计算或多阶段处理中，确保所有参与者在进入下一阶段之前都已完成当前阶段。

### 读写锁 (RwLock)

`RwLock<T>` (Reader-Writer Lock) 允许多个读任务同时访问共享数据，但在写任务访问时，所有读任务和写任务都被阻塞。它提供了比 `Mutex` 更高的并发性，适用于读多写少的场景。

-   **实现特点:** 内部使用 `Mutex` 和 `Semaphore` 来管理读写状态。写锁具有排他性，读锁之间可以共享。
-   **使用场景:** 保护需要频繁读取但很少写入的数据结构，例如配置信息或缓存。

## 使用示例

```rust
use crate::sync::mutex::Mutex;

static COUNTER: Mutex<usize> = Mutex::new(0);

pub fn increment_counter() {
    let mut guard = COUNTER.lock(); // 获取互斥锁
    *guard += 1;                  // 修改受保护的数据
    // guard 离开作用域时，自动释放互斥锁
}

pub fn get_counter() -> usize {
    let guard = COUNTER.lock(); // 获取互斥锁
    *guard                      // 读取受保护的数据
}
```

## 注意事项

-   由于 `no_std` 环境的限制，目前的许多同步原语都使用自旋等待。在多核系统中，长时间的自旋等待会浪费 CPU 周期。在需要更复杂调度策略和阻塞机制的场景中，可能需要进一步集成到内核的调度器中。
-   在使用 `Condvar` 时，请务必注意其简化实现，避免在不具备阻塞唤醒机制的环境中造成死循环。